// Autogenerated with StateSmith 0.19.0-alpha-1+5931a3a68e50c80e83349118a90569bf08270686.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#nullable enable

namespace BeziqueCore;

// Generated state machine
public partial class Bezique
{
    public enum EventId
    {
        DO = 0, // The `do` event is special. State event handlers do not consume this event (ancestors all get it too) unless a transition occurs.
        ALLPLAYERPLAYED = 1,
        AVAILABLECARDSONDECK = 2,
        COMPLETE = 3,
        DEALCOMPLETE = 4,
        DEALNOTCOMPLETE = 5,
        DECKEMPTY = 6,
        DRAWCARDTOALL = 7,
        FOURPLAYERGAME = 8,
        HANDEMPTY = 9,
        MELDOPPORTUNITY = 10,
        MELDPOINTGIVEN = 11,
        MORECARDSINHAND = 12,
        MOREPLAYERSTODRAW = 13,
        NOMELDOPPORTUNITY = 14,
        OPPONENTPLAYED = 15,
        OPPONENTTURN = 16,
        OTHERCARD = 17,
        PLAYERTURN = 18,
        TRUMP7 = 19,
        TWOPLAYERGAME = 20,
        WAITINGFOROPPONENT = 21,
        WINNINGSCORE = 22,
        WINNINGSCORENOTREACHED = 23,
    }

    public const int EventIdCount = 24;

    public enum StateId
    {
        ROOT = 0,
        ADD10POINTSTODEALER = 1,
        DEALFOURPLAYER = 2,
        DEAL4_FIRSTPLAYER = 3,
        DEAL4_FOURTHPLAYER = 4,
        DEAL4_SECONDPLAYER = 5,
        DEAL4_THIRDPLAYER = 6,
        DEALTWOPLAYER = 7,
        DEAL2_FIRSTPLAYER = 8,
        DEAL2_SECONDPLAYER = 9,
        FLIPTRUMP = 10,
        GAMEEND = 11,
        PLAYPHASE1 = 12,
        DECK = 13,
        DRAWACARD = 14,
        MELD = 15,
        PHASE1_PLAY = 16,
        PHASE1_TRICKSTART = 17,
        PHASE1_TRICKWINNER = 18,
        PHASE1_WAIT = 19,
        PLAYPHASE2 = 20,
        HAND = 21,
        PHASE2_PLAY = 22,
        PHASE2_TRICKSTART = 23,
        PHASE2_TRICKWINNER = 24,
        PHASE2_WAIT = 25,
        ROUNDEND = 26,
        STARTGAME = 27,
    }

    public const int StateIdCount = 28;

    // Used internally by state machine. Feel free to inspect, but don't modify.
    public StateId stateId;

    // State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
    public Bezique()
    {
    }

    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    public void Start()
    {
        ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.

            // ROOT.<InitialState> behavior
            // uml: TransitionTo(StartGame)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `StartGame`.
                STARTGAME_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }

    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    public void DispatchEvent(EventId eventId)
    {
        switch (this.stateId)
        {
            // STATE: Bezique
            case StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: Add10PointsToDealer
            case StateId.ADD10POINTSTODEALER:
                switch (eventId)
                {
                    case EventId.COMPLETE: ADD10POINTSTODEALER_complete(); break;
                }
                break;

            // STATE: DealFourPlayer
            case StateId.DEALFOURPLAYER:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: Deal4_FirstPlayer
            case StateId.DEAL4_FIRSTPLAYER:
                switch (eventId)
                {
                    case EventId.COMPLETE: DEAL4_FIRSTPLAYER_complete(); break;
                }
                break;

            // STATE: Deal4_FourthPlayer
            case StateId.DEAL4_FOURTHPLAYER:
                switch (eventId)
                {
                    case EventId.DEALNOTCOMPLETE: DEAL4_FOURTHPLAYER_dealnotcomplete(); break;
                    case EventId.DEALCOMPLETE: DEAL4_FOURTHPLAYER_dealcomplete(); break;
                }
                break;

            // STATE: Deal4_SecondPlayer
            case StateId.DEAL4_SECONDPLAYER:
                switch (eventId)
                {
                    case EventId.COMPLETE: DEAL4_SECONDPLAYER_complete(); break;
                }
                break;

            // STATE: Deal4_ThirdPlayer
            case StateId.DEAL4_THIRDPLAYER:
                switch (eventId)
                {
                    case EventId.COMPLETE: DEAL4_THIRDPLAYER_complete(); break;
                }
                break;

            // STATE: DealTwoPlayer
            case StateId.DEALTWOPLAYER:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: Deal2_FirstPlayer
            case StateId.DEAL2_FIRSTPLAYER:
                switch (eventId)
                {
                    case EventId.COMPLETE: DEAL2_FIRSTPLAYER_complete(); break;
                }
                break;

            // STATE: Deal2_SecondPlayer
            case StateId.DEAL2_SECONDPLAYER:
                switch (eventId)
                {
                    case EventId.DEALNOTCOMPLETE: DEAL2_SECONDPLAYER_dealnotcomplete(); break;
                    case EventId.DEALCOMPLETE: DEAL2_SECONDPLAYER_dealcomplete(); break;
                }
                break;

            // STATE: FlipTrump
            case StateId.FLIPTRUMP:
                switch (eventId)
                {
                    case EventId.TRUMP7: FLIPTRUMP_trump7(); break;
                    case EventId.OTHERCARD: FLIPTRUMP_othercard(); break;
                }
                break;

            // STATE: GameEnd
            case StateId.GAMEEND:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: PlayPhase1
            case StateId.PLAYPHASE1:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: Deck
            case StateId.DECK:
                switch (eventId)
                {
                    case EventId.DECKEMPTY: DECK_deckempty(); break;
                    case EventId.AVAILABLECARDSONDECK: DECK_availablecardsondeck(); break;
                }
                break;

            // STATE: DrawACard
            case StateId.DRAWACARD:
                switch (eventId)
                {
                    case EventId.MOREPLAYERSTODRAW: DRAWACARD_moreplayerstodraw(); break;
                    case EventId.DRAWCARDTOALL: DRAWACARD_drawcardtoall(); break;
                }
                break;

            // STATE: Meld
            case StateId.MELD:
                switch (eventId)
                {
                    case EventId.MELDPOINTGIVEN: MELD_meldpointgiven(); break;
                }
                break;

            // STATE: Phase1_Play
            case StateId.PHASE1_PLAY:
                switch (eventId)
                {
                    case EventId.WAITINGFOROPPONENT: PHASE1_PLAY_waitingforopponent(); break;
                    case EventId.ALLPLAYERPLAYED: PHASE1_PLAY_allplayerplayed(); break;
                }
                break;

            // STATE: Phase1_TrickStart
            case StateId.PHASE1_TRICKSTART:
                switch (eventId)
                {
                    case EventId.OPPONENTTURN: PHASE1_TRICKSTART_opponentturn(); break;
                    case EventId.PLAYERTURN: PHASE1_TRICKSTART_playerturn(); break;
                }
                break;

            // STATE: Phase1_TrickWinner
            case StateId.PHASE1_TRICKWINNER:
                switch (eventId)
                {
                    case EventId.MELDOPPORTUNITY: PHASE1_TRICKWINNER_meldopportunity(); break;
                    case EventId.NOMELDOPPORTUNITY: PHASE1_TRICKWINNER_nomeldopportunity(); break;
                }
                break;

            // STATE: Phase1_Wait
            case StateId.PHASE1_WAIT:
                switch (eventId)
                {
                    case EventId.OPPONENTPLAYED: PHASE1_WAIT_opponentplayed(); break;
                    case EventId.ALLPLAYERPLAYED: PHASE1_WAIT_allplayerplayed(); break;
                }
                break;

            // STATE: PlayPhase2
            case StateId.PLAYPHASE2:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: Hand
            case StateId.HAND:
                switch (eventId)
                {
                    case EventId.HANDEMPTY: HAND_handempty(); break;
                    case EventId.MORECARDSINHAND: HAND_morecardsinhand(); break;
                }
                break;

            // STATE: Phase2_Play
            case StateId.PHASE2_PLAY:
                switch (eventId)
                {
                    case EventId.ALLPLAYERPLAYED: PHASE2_PLAY_allplayerplayed(); break;
                    case EventId.WAITINGFOROPPONENT: PHASE2_PLAY_waitingforopponent(); break;
                }
                break;

            // STATE: Phase2_TrickStart
            case StateId.PHASE2_TRICKSTART:
                switch (eventId)
                {
                    case EventId.OPPONENTTURN: PHASE2_TRICKSTART_opponentturn(); break;
                    case EventId.PLAYERTURN: PHASE2_TRICKSTART_playerturn(); break;
                }
                break;

            // STATE: Phase2_TrickWinner
            case StateId.PHASE2_TRICKWINNER:
                switch (eventId)
                {
                    case EventId.DO: PHASE2_TRICKWINNER_do(); break;
                }
                break;

            // STATE: Phase2_Wait
            case StateId.PHASE2_WAIT:
                switch (eventId)
                {
                    case EventId.ALLPLAYERPLAYED: PHASE2_WAIT_allplayerplayed(); break;
                }
                break;

            // STATE: RoundEnd
            case StateId.ROUNDEND:
                switch (eventId)
                {
                    case EventId.WINNINGSCORE: ROUNDEND_winningscore(); break;
                    case EventId.WINNINGSCORENOTREACHED: ROUNDEND_winningscorenotreached(); break;
                }
                break;

            // STATE: StartGame
            case StateId.STARTGAME:
                switch (eventId)
                {
                    case EventId.TWOPLAYERGAME: STARTGAME_twoplayergame(); break;
                    case EventId.FOURPLAYERGAME: STARTGAME_fourplayergame(); break;
                }
                break;
        }

    }

    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    private void ExitUpToStateHandler(StateId desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case StateId.ADD10POINTSTODEALER: ADD10POINTSTODEALER_exit(); break;

                case StateId.DEALFOURPLAYER: DEALFOURPLAYER_exit(); break;

                case StateId.DEAL4_FIRSTPLAYER: DEAL4_FIRSTPLAYER_exit(); break;

                case StateId.DEAL4_FOURTHPLAYER: DEAL4_FOURTHPLAYER_exit(); break;

                case StateId.DEAL4_SECONDPLAYER: DEAL4_SECONDPLAYER_exit(); break;

                case StateId.DEAL4_THIRDPLAYER: DEAL4_THIRDPLAYER_exit(); break;

                case StateId.DEALTWOPLAYER: DEALTWOPLAYER_exit(); break;

                case StateId.DEAL2_FIRSTPLAYER: DEAL2_FIRSTPLAYER_exit(); break;

                case StateId.DEAL2_SECONDPLAYER: DEAL2_SECONDPLAYER_exit(); break;

                case StateId.FLIPTRUMP: FLIPTRUMP_exit(); break;

                case StateId.GAMEEND: GAMEEND_exit(); break;

                case StateId.PLAYPHASE1: PLAYPHASE1_exit(); break;

                case StateId.DECK: DECK_exit(); break;

                case StateId.DRAWACARD: DRAWACARD_exit(); break;

                case StateId.MELD: MELD_exit(); break;

                case StateId.PHASE1_PLAY: PHASE1_PLAY_exit(); break;

                case StateId.PHASE1_TRICKSTART: PHASE1_TRICKSTART_exit(); break;

                case StateId.PHASE1_TRICKWINNER: PHASE1_TRICKWINNER_exit(); break;

                case StateId.PHASE1_WAIT: PHASE1_WAIT_exit(); break;

                case StateId.PLAYPHASE2: PLAYPHASE2_exit(); break;

                case StateId.HAND: HAND_exit(); break;

                case StateId.PHASE2_PLAY: PHASE2_PLAY_exit(); break;

                case StateId.PHASE2_TRICKSTART: PHASE2_TRICKSTART_exit(); break;

                case StateId.PHASE2_TRICKWINNER: PHASE2_TRICKWINNER_exit(); break;

                case StateId.PHASE2_WAIT: PHASE2_WAIT_exit(); break;

                case StateId.ROUNDEND: ROUNDEND_exit(); break;

                case StateId.STARTGAME: STARTGAME_exit(); break;

                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////

    private void ROOT_enter()
    {
        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ADD10POINTSTODEALER
    ////////////////////////////////////////////////////////////////////////////////

    private void ADD10POINTSTODEALER_enter()
    {
        this.stateId = StateId.ADD10POINTSTODEALER;

        // Add10PointsToDealer behavior
        // uml: enter / { _adapter.Add10PointsToDealer(); }
        {
            // Step 1: execute action `_adapter.Add10PointsToDealer();`
            _adapter.Add10PointsToDealer();
        } // end of behavior for Add10PointsToDealer
    }

    private void ADD10POINTSTODEALER_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void ADD10POINTSTODEALER_complete()
    {
        // Add10PointsToDealer behavior
        // uml: Complete TransitionTo(PlayPhase1)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ADD10POINTSTODEALER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `PlayPhase1`.
            PLAYPHASE1_enter();

            // Finish transition by calling pseudo state transition function.
            PlayPhase1_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for Add10PointsToDealer

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DEALFOURPLAYER
    ////////////////////////////////////////////////////////////////////////////////

    private void DEALFOURPLAYER_enter()
    {
        this.stateId = StateId.DEALFOURPLAYER;
    }

    private void DEALFOURPLAYER_exit()
    {
        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DEAL4_FIRSTPLAYER
    ////////////////////////////////////////////////////////////////////////////////

    private void DEAL4_FIRSTPLAYER_enter()
    {
        this.stateId = StateId.DEAL4_FIRSTPLAYER;

        // Deal4_FirstPlayer behavior
        // uml: enter / { _adapter.DealThreeCards(); }
        {
            // Step 1: execute action `_adapter.DealThreeCards();`
            _adapter.DealThreeCards();
        } // end of behavior for Deal4_FirstPlayer
    }

    private void DEAL4_FIRSTPLAYER_exit()
    {
        this.stateId = StateId.DEALFOURPLAYER;
    }

    private void DEAL4_FIRSTPLAYER_complete()
    {
        // Deal4_FirstPlayer behavior
        // uml: Complete TransitionTo(Deal4_SecondPlayer)
        {
            // Step 1: Exit states until we reach `DealFourPlayer` state (Least Common Ancestor for transition).
            DEAL4_FIRSTPLAYER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Deal4_SecondPlayer`.
            DEAL4_SECONDPLAYER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Deal4_FirstPlayer

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DEAL4_FOURTHPLAYER
    ////////////////////////////////////////////////////////////////////////////////

    private void DEAL4_FOURTHPLAYER_enter()
    {
        this.stateId = StateId.DEAL4_FOURTHPLAYER;

        // Deal4_FourthPlayer behavior
        // uml: enter / { _adapter.DealThreeCards(); }
        {
            // Step 1: execute action `_adapter.DealThreeCards();`
            _adapter.DealThreeCards();
        } // end of behavior for Deal4_FourthPlayer
    }

    private void DEAL4_FOURTHPLAYER_exit()
    {
        this.stateId = StateId.DEALFOURPLAYER;
    }

    private void DEAL4_FOURTHPLAYER_dealcomplete()
    {
        // Deal4_FourthPlayer behavior
        // uml: DealComplete TransitionTo(FlipTrump)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `FlipTrump`.
            DEALTWOPLAYER_enter();
            FLIPTRUMP_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Deal4_FourthPlayer

        // No ancestor handles this event.
    }

    private void DEAL4_FOURTHPLAYER_dealnotcomplete()
    {
        // Deal4_FourthPlayer behavior
        // uml: DealNotComplete TransitionTo(Deal4_FirstPlayer)
        {
            // Step 1: Exit states until we reach `DealFourPlayer` state (Least Common Ancestor for transition).
            DEAL4_FOURTHPLAYER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Deal4_FirstPlayer`.
            DEAL4_FIRSTPLAYER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Deal4_FourthPlayer

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DEAL4_SECONDPLAYER
    ////////////////////////////////////////////////////////////////////////////////

    private void DEAL4_SECONDPLAYER_enter()
    {
        this.stateId = StateId.DEAL4_SECONDPLAYER;

        // Deal4_SecondPlayer behavior
        // uml: enter / { _adapter.DealThreeCards(); }
        {
            // Step 1: execute action `_adapter.DealThreeCards();`
            _adapter.DealThreeCards();
        } // end of behavior for Deal4_SecondPlayer
    }

    private void DEAL4_SECONDPLAYER_exit()
    {
        this.stateId = StateId.DEALFOURPLAYER;
    }

    private void DEAL4_SECONDPLAYER_complete()
    {
        // Deal4_SecondPlayer behavior
        // uml: Complete TransitionTo(Deal4_ThirdPlayer)
        {
            // Step 1: Exit states until we reach `DealFourPlayer` state (Least Common Ancestor for transition).
            DEAL4_SECONDPLAYER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Deal4_ThirdPlayer`.
            DEAL4_THIRDPLAYER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Deal4_SecondPlayer

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DEAL4_THIRDPLAYER
    ////////////////////////////////////////////////////////////////////////////////

    private void DEAL4_THIRDPLAYER_enter()
    {
        this.stateId = StateId.DEAL4_THIRDPLAYER;

        // Deal4_ThirdPlayer behavior
        // uml: enter / { _adapter.DealThreeCards(); }
        {
            // Step 1: execute action `_adapter.DealThreeCards();`
            _adapter.DealThreeCards();
        } // end of behavior for Deal4_ThirdPlayer
    }

    private void DEAL4_THIRDPLAYER_exit()
    {
        this.stateId = StateId.DEALFOURPLAYER;
    }

    private void DEAL4_THIRDPLAYER_complete()
    {
        // Deal4_ThirdPlayer behavior
        // uml: Complete TransitionTo(Deal4_FourthPlayer)
        {
            // Step 1: Exit states until we reach `DealFourPlayer` state (Least Common Ancestor for transition).
            DEAL4_THIRDPLAYER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Deal4_FourthPlayer`.
            DEAL4_FOURTHPLAYER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Deal4_ThirdPlayer

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DEALTWOPLAYER
    ////////////////////////////////////////////////////////////////////////////////

    private void DEALTWOPLAYER_enter()
    {
        this.stateId = StateId.DEALTWOPLAYER;
    }

    private void DEALTWOPLAYER_exit()
    {
        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DEAL2_FIRSTPLAYER
    ////////////////////////////////////////////////////////////////////////////////

    private void DEAL2_FIRSTPLAYER_enter()
    {
        this.stateId = StateId.DEAL2_FIRSTPLAYER;

        // Deal2_FirstPlayer behavior
        // uml: enter / { _adapter.DealThreeCards(); }
        {
            // Step 1: execute action `_adapter.DealThreeCards();`
            _adapter.DealThreeCards();
        } // end of behavior for Deal2_FirstPlayer
    }

    private void DEAL2_FIRSTPLAYER_exit()
    {
        this.stateId = StateId.DEALTWOPLAYER;
    }

    private void DEAL2_FIRSTPLAYER_complete()
    {
        // Deal2_FirstPlayer behavior
        // uml: Complete TransitionTo(Deal2_SecondPlayer)
        {
            // Step 1: Exit states until we reach `DealTwoPlayer` state (Least Common Ancestor for transition).
            DEAL2_FIRSTPLAYER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Deal2_SecondPlayer`.
            DEAL2_SECONDPLAYER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Deal2_FirstPlayer

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DEAL2_SECONDPLAYER
    ////////////////////////////////////////////////////////////////////////////////

    private void DEAL2_SECONDPLAYER_enter()
    {
        this.stateId = StateId.DEAL2_SECONDPLAYER;

        // Deal2_SecondPlayer behavior
        // uml: enter / { _adapter.DealThreeCards(); }
        {
            // Step 1: execute action `_adapter.DealThreeCards();`
            _adapter.DealThreeCards();
        } // end of behavior for Deal2_SecondPlayer
    }

    private void DEAL2_SECONDPLAYER_exit()
    {
        this.stateId = StateId.DEALTWOPLAYER;
    }

    private void DEAL2_SECONDPLAYER_dealcomplete()
    {
        // Deal2_SecondPlayer behavior
        // uml: DealComplete TransitionTo(FlipTrump)
        {
            // Step 1: Exit states until we reach `DealTwoPlayer` state (Least Common Ancestor for transition).
            DEAL2_SECONDPLAYER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `FlipTrump`.
            FLIPTRUMP_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Deal2_SecondPlayer

        // No ancestor handles this event.
    }

    private void DEAL2_SECONDPLAYER_dealnotcomplete()
    {
        // Deal2_SecondPlayer behavior
        // uml: DealNotComplete TransitionTo(Deal2_FirstPlayer)
        {
            // Step 1: Exit states until we reach `DealTwoPlayer` state (Least Common Ancestor for transition).
            DEAL2_SECONDPLAYER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Deal2_FirstPlayer`.
            DEAL2_FIRSTPLAYER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Deal2_SecondPlayer

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state FLIPTRUMP
    ////////////////////////////////////////////////////////////////////////////////

    private void FLIPTRUMP_enter()
    {
        this.stateId = StateId.FLIPTRUMP;

        // FlipTrump behavior
        // uml: enter / { _adapter.FlipCard(); }
        {
            // Step 1: execute action `_adapter.FlipCard();`
            _adapter.FlipCard();
        } // end of behavior for FlipTrump
    }

    private void FLIPTRUMP_exit()
    {
        this.stateId = StateId.DEALTWOPLAYER;
    }

    private void FLIPTRUMP_othercard()
    {
        // FlipTrump behavior
        // uml: OtherCard TransitionTo(PlayPhase1)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `PlayPhase1`.
            PLAYPHASE1_enter();

            // Finish transition by calling pseudo state transition function.
            PlayPhase1_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for FlipTrump

        // No ancestor handles this event.
    }

    private void FLIPTRUMP_trump7()
    {
        // FlipTrump behavior
        // uml: Trump7 TransitionTo(Add10PointsToDealer)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Add10PointsToDealer`.
            ADD10POINTSTODEALER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for FlipTrump

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state GAMEEND
    ////////////////////////////////////////////////////////////////////////////////

    private void GAMEEND_enter()
    {
        this.stateId = StateId.GAMEEND;
    }

    private void GAMEEND_exit()
    {
        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYPHASE1
    ////////////////////////////////////////////////////////////////////////////////

    private void PLAYPHASE1_enter()
    {
        this.stateId = StateId.PLAYPHASE1;
    }

    private void PLAYPHASE1_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void PlayPhase1_InitialState_transition()
    {
        // PlayPhase1.<InitialState> behavior
        // uml: TransitionTo(Phase1_TrickStart)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase1_TrickStart`.
            PHASE1_TRICKSTART_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PlayPhase1.<InitialState>
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DECK
    ////////////////////////////////////////////////////////////////////////////////

    private void DECK_enter()
    {
        this.stateId = StateId.DECK;

        // Deck behavior
        // uml: enter / { _adapter.CheckDeckCardCount(); }
        {
            // Step 1: execute action `_adapter.CheckDeckCardCount();`
            _adapter.CheckDeckCardCount();
        } // end of behavior for Deck
    }

    private void DECK_exit()
    {
        this.stateId = StateId.PLAYPHASE1;
    }

    private void DECK_availablecardsondeck()
    {
        // Deck behavior
        // uml: AvailableCardsOnDeck TransitionTo(Phase1_TrickStart)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            DECK_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase1_TrickStart`.
            PHASE1_TRICKSTART_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Deck

        // No ancestor handles this event.
    }

    private void DECK_deckempty()
    {
        // Deck behavior
        // uml: DeckEmpty TransitionTo(PlayPhase2)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            DECK_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `PlayPhase2`.
            PLAYPHASE2_enter();

            // PlayPhase2.<InitialState> behavior
            // uml: TransitionTo(Phase2_TrickStart)
            {
                // Step 1: Exit states until we reach `PlayPhase2` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `Phase2_TrickStart`.
                PHASE2_TRICKSTART_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for PlayPhase2.<InitialState>
        } // end of behavior for Deck

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DRAWACARD
    ////////////////////////////////////////////////////////////////////////////////

    private void DRAWACARD_enter()
    {
        this.stateId = StateId.DRAWACARD;

        // DrawACard behavior
        // uml: enter / { _adapter.DrawCardFromDeck(); }
        {
            // Step 1: execute action `_adapter.DrawCardFromDeck();`
            _adapter.DrawCardFromDeck();
        } // end of behavior for DrawACard
    }

    private void DRAWACARD_exit()
    {
        this.stateId = StateId.PLAYPHASE1;
    }

    private void DRAWACARD_drawcardtoall()
    {
        // DrawACard behavior
        // uml: DrawCardToAll TransitionTo(Deck)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            DRAWACARD_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Deck`.
            DECK_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DrawACard

        // No ancestor handles this event.
    }

    private void DRAWACARD_moreplayerstodraw()
    {
        // DrawACard behavior
        // uml: MorePlayersToDraw TransitionTo(DrawACard)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            DRAWACARD_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `DrawACard`.
            DRAWACARD_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DrawACard

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state MELD
    ////////////////////////////////////////////////////////////////////////////////

    private void MELD_enter()
    {
        this.stateId = StateId.MELD;

        // Meld behavior
        // uml: enter / { _adapter.AddMeldPoint(); }
        {
            // Step 1: execute action `_adapter.AddMeldPoint();`
            _adapter.AddMeldPoint();
        } // end of behavior for Meld
    }

    private void MELD_exit()
    {
        this.stateId = StateId.PLAYPHASE1;
    }

    private void MELD_meldpointgiven()
    {
        // Meld behavior
        // uml: MeldPointGiven TransitionTo(DrawACard)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            MELD_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `DrawACard`.
            DRAWACARD_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Meld

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PHASE1_PLAY
    ////////////////////////////////////////////////////////////////////////////////

    private void PHASE1_PLAY_enter()
    {
        this.stateId = StateId.PHASE1_PLAY;

        // Phase1_Play behavior
        // uml: enter / { _adapter.AllPlayerPlayed(); }
        {
            // Step 1: execute action `_adapter.AllPlayerPlayed();`
            _adapter.AllPlayerPlayed();
        } // end of behavior for Phase1_Play
    }

    private void PHASE1_PLAY_exit()
    {
        this.stateId = StateId.PLAYPHASE1;
    }

    private void PHASE1_PLAY_allplayerplayed()
    {
        // Phase1_Play behavior
        // uml: AllPlayerPlayed TransitionTo(Phase1_TrickWinner)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            PHASE1_PLAY_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase1_TrickWinner`.
            PHASE1_TRICKWINNER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase1_Play

        // No ancestor handles this event.
    }

    private void PHASE1_PLAY_waitingforopponent()
    {
        // Phase1_Play behavior
        // uml: WaitingForOpponent TransitionTo(Phase1_Wait)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            PHASE1_PLAY_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase1_Wait`.
            PHASE1_WAIT_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase1_Play

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PHASE1_TRICKSTART
    ////////////////////////////////////////////////////////////////////////////////

    private void PHASE1_TRICKSTART_enter()
    {
        this.stateId = StateId.PHASE1_TRICKSTART;
    }

    private void PHASE1_TRICKSTART_exit()
    {
        this.stateId = StateId.PLAYPHASE1;
    }

    private void PHASE1_TRICKSTART_opponentturn()
    {
        // Phase1_TrickStart behavior
        // uml: OpponentTurn TransitionTo(Phase1_Wait)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            PHASE1_TRICKSTART_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase1_Wait`.
            PHASE1_WAIT_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase1_TrickStart

        // No ancestor handles this event.
    }

    private void PHASE1_TRICKSTART_playerturn()
    {
        // Phase1_TrickStart behavior
        // uml: PlayerTurn TransitionTo(Phase1_Play)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            PHASE1_TRICKSTART_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase1_Play`.
            PHASE1_PLAY_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase1_TrickStart

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PHASE1_TRICKWINNER
    ////////////////////////////////////////////////////////////////////////////////

    private void PHASE1_TRICKWINNER_enter()
    {
        this.stateId = StateId.PHASE1_TRICKWINNER;

        // Phase1_TrickWinner behavior
        // uml: enter / { _adapter.DetermineWinner(); }
        {
            // Step 1: execute action `_adapter.DetermineWinner();`
            _adapter.DetermineWinner();
        } // end of behavior for Phase1_TrickWinner
    }

    private void PHASE1_TRICKWINNER_exit()
    {
        this.stateId = StateId.PLAYPHASE1;
    }

    private void PHASE1_TRICKWINNER_meldopportunity()
    {
        // Phase1_TrickWinner behavior
        // uml: MeldOpportunity TransitionTo(Meld)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            PHASE1_TRICKWINNER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Meld`.
            MELD_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase1_TrickWinner

        // No ancestor handles this event.
    }

    private void PHASE1_TRICKWINNER_nomeldopportunity()
    {
        // Phase1_TrickWinner behavior
        // uml: NoMeldOpportunity TransitionTo(DrawACard)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            PHASE1_TRICKWINNER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `DrawACard`.
            DRAWACARD_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase1_TrickWinner

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PHASE1_WAIT
    ////////////////////////////////////////////////////////////////////////////////

    private void PHASE1_WAIT_enter()
    {
        this.stateId = StateId.PHASE1_WAIT;

        // Phase1_Wait behavior
        // uml: enter / { _adapter.AllPlayerPlayed(); }
        {
            // Step 1: execute action `_adapter.AllPlayerPlayed();`
            _adapter.AllPlayerPlayed();
        } // end of behavior for Phase1_Wait
    }

    private void PHASE1_WAIT_exit()
    {
        this.stateId = StateId.PLAYPHASE1;
    }

    private void PHASE1_WAIT_allplayerplayed()
    {
        // Phase1_Wait behavior
        // uml: AllPlayerPlayed TransitionTo(Phase1_TrickWinner)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            PHASE1_WAIT_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase1_TrickWinner`.
            PHASE1_TRICKWINNER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase1_Wait

        // No ancestor handles this event.
    }

    private void PHASE1_WAIT_opponentplayed()
    {
        // Phase1_Wait behavior
        // uml: OpponentPlayed TransitionTo(Phase1_Play)
        {
            // Step 1: Exit states until we reach `PlayPhase1` state (Least Common Ancestor for transition).
            PHASE1_WAIT_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase1_Play`.
            PHASE1_PLAY_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase1_Wait

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYPHASE2
    ////////////////////////////////////////////////////////////////////////////////

    private void PLAYPHASE2_enter()
    {
        this.stateId = StateId.PLAYPHASE2;
    }

    private void PLAYPHASE2_exit()
    {
        this.stateId = StateId.PLAYPHASE1;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state HAND
    ////////////////////////////////////////////////////////////////////////////////

    private void HAND_enter()
    {
        this.stateId = StateId.HAND;

        // Hand behavior
        // uml: enter / { _adapter.CheckCardsOnHand(); }
        {
            // Step 1: execute action `_adapter.CheckCardsOnHand();`
            _adapter.CheckCardsOnHand();
        } // end of behavior for Hand
    }

    private void HAND_exit()
    {
        this.stateId = StateId.PLAYPHASE2;
    }

    private void HAND_handempty()
    {
        // Hand behavior
        // uml: HandEmpty TransitionTo(RoundEnd)
        {
            // Step 1: Exit states until we reach `PlayPhase2` state (Least Common Ancestor for transition).
            HAND_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `RoundEnd`.
            ROUNDEND_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Hand

        // No ancestor handles this event.
    }

    private void HAND_morecardsinhand()
    {
        // Hand behavior
        // uml: MoreCardsInHand TransitionTo(Phase2_TrickStart)
        {
            // Step 1: Exit states until we reach `PlayPhase2` state (Least Common Ancestor for transition).
            HAND_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase2_TrickStart`.
            PHASE2_TRICKSTART_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Hand

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PHASE2_PLAY
    ////////////////////////////////////////////////////////////////////////////////

    private void PHASE2_PLAY_enter()
    {
        this.stateId = StateId.PHASE2_PLAY;

        // Phase2_Play behavior
        // uml: enter / { _adapter.AllPlayerPlayed(); }
        {
            // Step 1: execute action `_adapter.AllPlayerPlayed();`
            _adapter.AllPlayerPlayed();
        } // end of behavior for Phase2_Play
    }

    private void PHASE2_PLAY_exit()
    {
        this.stateId = StateId.PLAYPHASE2;
    }

    private void PHASE2_PLAY_allplayerplayed()
    {
        // Phase2_Play behavior
        // uml: AllPlayerPlayed TransitionTo(Phase2_TrickWinner)
        {
            // Step 1: Exit states until we reach `PlayPhase2` state (Least Common Ancestor for transition).
            PHASE2_PLAY_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase2_TrickWinner`.
            PHASE2_TRICKWINNER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase2_Play

        // No ancestor handles this event.
    }

    private void PHASE2_PLAY_waitingforopponent()
    {
        // Phase2_Play behavior
        // uml: WaitingForOpponent TransitionTo(Phase2_Wait)
        {
            // Step 1: Exit states until we reach `PlayPhase2` state (Least Common Ancestor for transition).
            PHASE2_PLAY_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase2_Wait`.
            PHASE2_WAIT_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase2_Play

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PHASE2_TRICKSTART
    ////////////////////////////////////////////////////////////////////////////////

    private void PHASE2_TRICKSTART_enter()
    {
        this.stateId = StateId.PHASE2_TRICKSTART;
    }

    private void PHASE2_TRICKSTART_exit()
    {
        this.stateId = StateId.PLAYPHASE2;
    }

    private void PHASE2_TRICKSTART_opponentturn()
    {
        // Phase2_TrickStart behavior
        // uml: OpponentTurn TransitionTo(Phase2_Wait)
        {
            // Step 1: Exit states until we reach `PlayPhase2` state (Least Common Ancestor for transition).
            PHASE2_TRICKSTART_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase2_Wait`.
            PHASE2_WAIT_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase2_TrickStart

        // No ancestor handles this event.
    }

    private void PHASE2_TRICKSTART_playerturn()
    {
        // Phase2_TrickStart behavior
        // uml: PlayerTurn TransitionTo(Phase2_Play)
        {
            // Step 1: Exit states until we reach `PlayPhase2` state (Least Common Ancestor for transition).
            PHASE2_TRICKSTART_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase2_Play`.
            PHASE2_PLAY_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase2_TrickStart

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PHASE2_TRICKWINNER
    ////////////////////////////////////////////////////////////////////////////////

    private void PHASE2_TRICKWINNER_enter()
    {
        this.stateId = StateId.PHASE2_TRICKWINNER;

        // Phase2_TrickWinner behavior
        // uml: enter / { _adapter.DetermineWinner(); }
        {
            // Step 1: execute action `_adapter.DetermineWinner();`
            _adapter.DetermineWinner();
        } // end of behavior for Phase2_TrickWinner
    }

    private void PHASE2_TRICKWINNER_exit()
    {
        this.stateId = StateId.PLAYPHASE2;
    }

    private void PHASE2_TRICKWINNER_do()
    {
        // Phase2_TrickWinner behavior
        // uml: do TransitionTo(Hand)
        {
            // Step 1: Exit states until we reach `PlayPhase2` state (Least Common Ancestor for transition).
            PHASE2_TRICKWINNER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Hand`.
            HAND_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase2_TrickWinner

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PHASE2_WAIT
    ////////////////////////////////////////////////////////////////////////////////

    private void PHASE2_WAIT_enter()
    {
        this.stateId = StateId.PHASE2_WAIT;

        // Phase2_Wait behavior
        // uml: enter / { _adapter.AllPlayerPlayed(); }
        {
            // Step 1: execute action `_adapter.AllPlayerPlayed();`
            _adapter.AllPlayerPlayed();
        } // end of behavior for Phase2_Wait
    }

    private void PHASE2_WAIT_exit()
    {
        this.stateId = StateId.PLAYPHASE2;
    }

    private void PHASE2_WAIT_allplayerplayed()
    {
        // Phase2_Wait behavior
        // uml: AllPlayerPlayed TransitionTo(Phase2_TrickWinner)
        {
            // Step 1: Exit states until we reach `PlayPhase2` state (Least Common Ancestor for transition).
            PHASE2_WAIT_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Phase2_TrickWinner`.
            PHASE2_TRICKWINNER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Phase2_Wait

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROUNDEND
    ////////////////////////////////////////////////////////////////////////////////

    private void ROUNDEND_enter()
    {
        this.stateId = StateId.ROUNDEND;
    }

    private void ROUNDEND_exit()
    {
        this.stateId = StateId.PLAYPHASE2;
    }

    private void ROUNDEND_winningscore()
    {
        // RoundEnd behavior
        // uml: WinningScore TransitionTo(GameEnd)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `GameEnd`.
            GAMEEND_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RoundEnd

        // No ancestor handles this event.
    }

    private void ROUNDEND_winningscorenotreached()
    {
        // RoundEnd behavior
        // uml: WinningScoreNotReached TransitionTo(StartGame)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `StartGame`.
            STARTGAME_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RoundEnd

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state STARTGAME
    ////////////////////////////////////////////////////////////////////////////////

    private void STARTGAME_enter()
    {
        this.stateId = StateId.STARTGAME;
    }

    private void STARTGAME_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void STARTGAME_fourplayergame()
    {
        // StartGame behavior
        // uml: FourPlayerGame TransitionTo(DealFourPlayer)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            STARTGAME_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `DealFourPlayer`.
            DEALFOURPLAYER_enter();

            // DealFourPlayer.<InitialState> behavior
            // uml: TransitionTo(Deal4_FirstPlayer)
            {
                // Step 1: Exit states until we reach `DealFourPlayer` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `Deal4_FirstPlayer`.
                DEAL4_FIRSTPLAYER_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for DealFourPlayer.<InitialState>
        } // end of behavior for StartGame

        // No ancestor handles this event.
    }

    private void STARTGAME_twoplayergame()
    {
        // StartGame behavior
        // uml: TwoPlayerGame TransitionTo(DealTwoPlayer)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            STARTGAME_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `DealTwoPlayer`.
            DEALTWOPLAYER_enter();

            // DealTwoPlayer.<InitialState> behavior
            // uml: TransitionTo(Deal2_FirstPlayer)
            {
                // Step 1: Exit states until we reach `DealTwoPlayer` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `Deal2_FirstPlayer`.
                DEAL2_FIRSTPLAYER_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for DealTwoPlayer.<InitialState>
        } // end of behavior for StartGame

        // No ancestor handles this event.
    }

    // Thread safe.
    public static string StateIdToString(StateId id)
    {
        switch (id)
        {
            case StateId.ROOT: return "ROOT";
            case StateId.ADD10POINTSTODEALER: return "ADD10POINTSTODEALER";
            case StateId.DEALFOURPLAYER: return "DEALFOURPLAYER";
            case StateId.DEAL4_FIRSTPLAYER: return "DEAL4_FIRSTPLAYER";
            case StateId.DEAL4_FOURTHPLAYER: return "DEAL4_FOURTHPLAYER";
            case StateId.DEAL4_SECONDPLAYER: return "DEAL4_SECONDPLAYER";
            case StateId.DEAL4_THIRDPLAYER: return "DEAL4_THIRDPLAYER";
            case StateId.DEALTWOPLAYER: return "DEALTWOPLAYER";
            case StateId.DEAL2_FIRSTPLAYER: return "DEAL2_FIRSTPLAYER";
            case StateId.DEAL2_SECONDPLAYER: return "DEAL2_SECONDPLAYER";
            case StateId.FLIPTRUMP: return "FLIPTRUMP";
            case StateId.GAMEEND: return "GAMEEND";
            case StateId.PLAYPHASE1: return "PLAYPHASE1";
            case StateId.DECK: return "DECK";
            case StateId.DRAWACARD: return "DRAWACARD";
            case StateId.MELD: return "MELD";
            case StateId.PHASE1_PLAY: return "PHASE1_PLAY";
            case StateId.PHASE1_TRICKSTART: return "PHASE1_TRICKSTART";
            case StateId.PHASE1_TRICKWINNER: return "PHASE1_TRICKWINNER";
            case StateId.PHASE1_WAIT: return "PHASE1_WAIT";
            case StateId.PLAYPHASE2: return "PLAYPHASE2";
            case StateId.HAND: return "HAND";
            case StateId.PHASE2_PLAY: return "PHASE2_PLAY";
            case StateId.PHASE2_TRICKSTART: return "PHASE2_TRICKSTART";
            case StateId.PHASE2_TRICKWINNER: return "PHASE2_TRICKWINNER";
            case StateId.PHASE2_WAIT: return "PHASE2_WAIT";
            case StateId.ROUNDEND: return "ROUNDEND";
            case StateId.STARTGAME: return "STARTGAME";
            default: return "?";
        }
    }

    // Thread safe.
    public static string EventIdToString(EventId id)
    {
        switch (id)
        {
            case EventId.ALLPLAYERPLAYED: return "ALLPLAYERPLAYED";
            case EventId.AVAILABLECARDSONDECK: return "AVAILABLECARDSONDECK";
            case EventId.COMPLETE: return "COMPLETE";
            case EventId.DEALCOMPLETE: return "DEALCOMPLETE";
            case EventId.DEALNOTCOMPLETE: return "DEALNOTCOMPLETE";
            case EventId.DECKEMPTY: return "DECKEMPTY";
            case EventId.DO: return "DO";
            case EventId.DRAWCARDTOALL: return "DRAWCARDTOALL";
            case EventId.FOURPLAYERGAME: return "FOURPLAYERGAME";
            case EventId.HANDEMPTY: return "HANDEMPTY";
            case EventId.MELDOPPORTUNITY: return "MELDOPPORTUNITY";
            case EventId.MELDPOINTGIVEN: return "MELDPOINTGIVEN";
            case EventId.MORECARDSINHAND: return "MORECARDSINHAND";
            case EventId.MOREPLAYERSTODRAW: return "MOREPLAYERSTODRAW";
            case EventId.NOMELDOPPORTUNITY: return "NOMELDOPPORTUNITY";
            case EventId.OPPONENTPLAYED: return "OPPONENTPLAYED";
            case EventId.OPPONENTTURN: return "OPPONENTTURN";
            case EventId.OTHERCARD: return "OTHERCARD";
            case EventId.PLAYERTURN: return "PLAYERTURN";
            case EventId.TRUMP7: return "TRUMP7";
            case EventId.TWOPLAYERGAME: return "TWOPLAYERGAME";
            case EventId.WAITINGFOROPPONENT: return "WAITINGFOROPPONENT";
            case EventId.WINNINGSCORE: return "WINNINGSCORE";
            case EventId.WINNINGSCORENOTREACHED: return "WINNINGSCORENOTREACHED";
            default: return "?";
        }
    }
}
